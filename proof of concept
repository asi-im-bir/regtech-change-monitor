Proof of Concept: Automated RegTech Change Monitor Project Overview and Problem Statement1.1 The Problem ðŸ˜«The core issue is that manual regulatory tracking poses a high audit risk. GRC teams must verify compliance against dozens of frequently updated external standards (e.g., NIS2, AI Act). Relying on analysts to check these websites weekly is slow, inefficient, and creates an unacceptable audit gap if a critical deadline is missed.1.2 The Solution âœ…The solution is a lightweight, scalable system that automates the identification and logging of regulatory text changes. This system establishes continuous monitoringâ€”a core requirement of modern GRC and security frameworks.ComponentFunctionOutcomeAutomationPython/GitHub Actions (Cron)Guarantees daily compliance checks without human intervention.Scopemonitor_targets.jsonCentralizes a scalable list of URLs and content selectors.VerificationGit History/JSON LogsProvides an immutable, timestamped Audit Trail of all activity.2. Technical Architecture and Data FlowThe project uses a Human-in-the-Loop model. Automation handles detection (low value, high frequency), and the GRC analyst handles risk assessment (high value, low frequency).2.1 Architecture DiagramData Flow Summary:Trigger: GitHub Actions runs the scheduler (cron).Input: The script reads the Targets List (monitor_targets.json).Process: For each target, the script performs three tasks:Fetch: Sends an HTTP request to the target URL.Compare: Compares the Live Content to the Last Approved Baseline (*_baseline.txt).Log: Records the status (OK or CHANGE_DETECTED).Output: The Git system automatically commits the updated Audit Log (status_log.json) to the repository.2.2 The Baseline File ConceptThe *_baseline.txt files are essential for the audit trail:The *_baseline.txt file represents the last version of the regulatory text that the GRC team certified as compliant.The script's core job is to check if the Live Website is different from the Baseline.If a difference is found, the system flags the old baseline in Git history and saves the new text to a temporary *_new_content.txt file, forcing human review before the change is officially adopted.3. Real-World Inputs, Outputs, and Utilization3.1 Required Inputs (Configuration)The operational stability relies on correctly configuring the following inputs (which should remain separate from the Python code):Targets List (monitor_targets.json): Analyst provides the target_url, regulation_name, and the exact CSS selector (#ID or .Class) needed to isolate the critical text block on the webpage.Execution Environment: GitHub Secrets (or Windows Environment Variables) must be configured with a single, general REGULATION_NAME for the entire monitoring project.3.2 Outputs and Change ControlOutput TypeTrigger EventResulting GRC ActionOutputs (Audit/OK)Daily Run SuccessAction: System commits the updated status_log.json (status: OK). This is the primary audit evidence.Outputs (Alert/Action)Live Content != BaselineALERT: Analyst is notified via the GitHub Action log/console output. Action: Analyst downloads the *_new_content.txt and starts a Risk Impact Assessment.Output ReasonConnection/Selector FailuresMaintenance: The logged error message (e.g., "Selector not found") directs the analyst to immediately troubleshoot the configuration, preserving system integrity.3.3 Organizational Benefits ðŸš€This tool directly addresses the need for Immutability and Focus on Risk within the GRC function:Focus on Strategy: Eliminates time wasted on checking websites, allowing the GRC analyst to concentrate on strategic security tasks.Traceability: Creates a permanent record of every compliance status, protecting the organization from questions about the date a regulation changed or the time the organization responded.